# 1 <= N <= 1,000,000
# 1 <= M <= 2,000,000,000
# height <= 100,000,000

# 파라메트릭 서치

# 떡의 개수, 요청한 떡의 길이
n, m = map(int, input().split())
height = list(map(int, input().split())) # [19, 15, 10, 17]

left = 0
right = max(height)

result = 0
while left <= right: # 0, 19
  total = 0 # 만들어진 떡의 길이
  mid = (left + right) // 2 # 9, 14
  
  for i in height:
    if i > mid: # 19, 15, 10, 17 다 큼 
      total += i - mid # 10, 6, 1, 8 = (25) ---- 5, 1, 3 = (9) 
      print("토탈 변화", total, i, mid)
  
  # 요청한 떡의 길이보다 짧은 경우
  if total < m:
    right = mid - 1
    print("떡의 양이 부족한 경우 왼쪽 탐색", right, mid)
    
  # 요청한 떡의 길이보다 긴 경우
  else:
    result = mid
    left = mid + 1
    print("떡의 양이 충분한 경우", result, left, mid)

print(result)

"""
4 6
19 15 10 17

답: 15
"""

'''
처음 [19, 15, 10, 17]의 떡을 가지고 절단을 시작한다.
이진 탐색을 위해 첫 절단의 길이 mid는 (0 + 19) // 2 를 했기 때문에 9가 나온다.

그리고 떡의 길이를 절단하여 뽑은 총 떡의 합산을 구한다.
첫 순회 떄는 total이 25가 나온다.

#순회 (1)
left는 0, right는 19, mid는 9로 시작한다.
이 25는 19 > 9(mid), 15 > 9(mid)... 이렇게 height에 있는 모든 값들이 9(mid)보다 컸기 때문에 토탈 25가 나온다.
요청한 길이는 m의 값인 6이기 때문에 너무 많이 뽑았다.

이제 시작점 left를 mid + 1 값으로 옮긴다.

# 순회 (2)
mid는 left(10) + end(19) // 2를 해서 14가 나온다.
떡의 길이를 절단하자. total은 9가 나온다.

19 - 14 = 5, 15 - 14 = 1, 10은 다 잘려서 없음, 17 - 4 = 3
5 + 1 + 3 = 9가 나오게 된다.

이 9도 요청한 길이보다 크기 때문에 한번 더 마무리한다.
시작점 left는 mid + 1로 15가 된다.

# 순회 (3)
mid는 left(15) + end(19) // 2를 해서 17이 나온다.
떡의 길이를 절단하자. 

19 - 17 = 2, 15는 잘려서 없음, 10도 잘려서 없음, 17도 다 잘림
토탈은 2가 나오게 된다.

2는 요청한 길이 9보다 작다.
그렇기 때문에 끝점 19 - 1을 해서 right를 18로 내려보자.

# 순회 (4)
left는 15, right는 16이 된다. mid는 15가 된다.
떡의 길이를 절단하자.
19 - 15 = 4, 17 - 15 = 2를 해서 딱 맞게 6이 드디어 된다.

이제 떡이 충분한 경우인 else문에서 result는 mid값인 15가 되고
left = mid + 1을 해서 left = 16, right 16이 되어서 while문이 종료된다.
'''